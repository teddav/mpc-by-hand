# Implementation of the Chou-Orlandi [`CO15`](https://eprint.iacr.org/2015/267.pdf)
# Elliptic Curve Diffie-Hellman-based 1-out-of-2 base OT
# Additive notation is used for elliptic curve groups compared DH with multiplicative used in the paper.
import os

# Using Curve25519 in Montgomery form: y^2 = x^3 + 486662x^2 + x
p = 2**255 - 19
Fp = GF(p)
ec = EllipticCurve(Fp, [0, 486662, 0, 1, 0])
# The base point of the prime-order subgroup is at x = 9 to find y, solve the equation of the curve
g = ec.lift_x(9)
n = g.order() # order of the subgroup generated by g

# Simple encryption and decryption functions with XOR
def encrypt(m, k):
    m_int = int.from_bytes(m, 'big')
    return m_int ^^ k

def decrypt(c, k):
    m_int = c ^^ k
    return m_int.to_bytes(16, 'big')

# Step 1
# Alice creates its private key and messages to send
a = ZZ.random_element(n) # random number in [0, n - 1]
M0 = os.urandom(16)
M1 = os.urandom(16)
# Alice sends its public key to Bob
# this message is reusable in different instance of the protocol for batching
A = a * g

# Step 2
# Bob creates its private key
b = ZZ.random_element(n)
# Bob chooses a bit c and create its public key depending on it.
# If c = 0, then B = g^b, else B = A * g^b
# Bob sends it to Alice.
c = randrange(0, 2)
B = b * g if c == 0 else A + b * g

# Step 3
# Alice receives the public key B and computes 2 keys for symmetric encryption:
k0 = hash(a * B)
k1 = hash(a * (B - A))
# Then it encrypts M0 with k0 and M1 with k1 and send them to Bob
e0 = encrypt(M0, k0)
e1 = encrypt(M1, k1)

# Step 4
# Bob compute its key kb = hash(b * A)
kb = hash(b * A)
# Bob receives e0 and e1, he knows which value he chose for c and can decrypt
# the corresponding message.
message = decrypt(e0, kb) if c == 0 else decrypt(e1, kb)

# Verification
if c == 0:
    assert message == M0
    print("Successfully decrypted M0")
else: # c == 1
    assert message == M1
    print("Successfully decrypted M1")

# All of this works due to how the symmetric keys are computed.
# Alice public key is A = a * g
# Bob public key is B = b * g if c == 0 else A + b * g
# Bob symmetric key is kb = hash(b * A) = hash(b * a * g)
# Alice symmetric key are k0 = hash(a * B) and k1 = hash(a * (B - A))
# By substituting the public keys in the symmetric keys depending on c, we get:
# if c == 0:
#     k0 = hash(a * (b * g)) = hash(a * b * g)
#     k1 = hash(a * (b * g - a * g)) = hash(a * (b - a) * g)
# if c == 1:
#     k0 = hash(a * (A + b * g)) = hash(a * (a * g + b * g)) = hash(a * (a + b) * g)
#     k1 = hash(a * (A + b * g - A)) = hash(a * b * g)
# Hence Bob key always decrypts the message corresponding to his choice of c.

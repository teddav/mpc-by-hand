# Actively secure KOS OT Extension: Correlated random oblivious transfer extension protocol with leakage
# based on KOS15 https://eprint.iacr.org/2015/546.pdf
# This is the implementation of the MPZ KOS version of the protocol.
# The goal is to verify that the Receiver was honest and used a unique choice vector.
# Implements figure 7 of the paper which uses the core OT extension
# from Figure 3 as its first phase.
#
# Note that figure 3 is based on the IKNP extension with a few different notational changes and optimizations:
#   * Compared to IKNP, it stops before hashing the output with the random oracle and performing
#     the final round of communication.
#   * In KOS protocol, figure 3 details how to reduce the communication of the base OT:
#     It only transmit the k-bit seeds used to generate m-bit vectors.
#     Hence it is a reduction from k OT of size m to k OT of size k.
#     See paragraph 1.3 from https://nishkum.github.io/files/OT_extension.pdf
#   * The base OT in IKNP outputs qⱼ = tⱼ ⊕ (rⱼ⋅s) which is the same as qⱼ = tⱼ ⊕ (xⱼ⋅Δ) in KOS
#     with xj == rj, Δ == s and tj == tj
#   * For reminder in IKNP, r is the receiver's choice vector and s is a random vector generated by the sender.
#
# In this implementation, we will focus on figure 7 of the paper with the correlation check.

F2 = GF(2)

l = 16  # number of wanted OT instances
k = 16  # security parameter
s = 16  # statistical security parameter
# Total number of OT instances from the IKNP OT extension
# l' = l + k + s
l_extended = l + k + s

# Step 0: setup the end of the figure 3 (IKNP based)
# random vector generated by the sender
delta = vector([F2.random_element() for _ in range(k)])
# receiver's choice vector in [0, l] and random bits in [l + 1, l' - 1]
# The random bits are used to blind the choice vector and will be discarded at the end
x = [F2.random_element() for _ in range(l_extended)]
X = Matrix(F2, [x for _ in range(k)])
# To have l' rows and k columns with the choice vector in each row
X = X.transpose()
# Create random matrix T of size l' × k (l' rows, k columns)
T = matrix(F2, [[F2.random_element() for _ in range(k)] for _ in range(l_extended)])
# qj = tj + xj * delta
Q = matrix(F2, [T.row(i) + X.row(i).pairwise_product(delta) for i in range(l_extended)])

# Step 1: generate Chi's (random weights)
# Simplified version of the random functionality
# It should be implemented using a standard hash-based commitment scheme,
# where both parties commit to and then open a seed, then the XOR of the
# two values is used to seed a PRG
# See paragraph 5 of the paper and https://o1-labs.github.io/proof-systems/fundamentals/zkbook_2pc/ote.html
chi = Matrix(F2, [[F2.random_element() for _ in range(k)] for _ in range(l_extended)])

# Step 2: compute the weighted sums
x_weighted = sum(chi.row(i) * x[i] for i in range(l_extended))
t_weighted = sum(chi.row(i) * T.row(i) for i in range(l_extended))
q_weighted = sum(chi.row(i) * Q.row(i) for i in range(l_extended))

# Step 3 assert t = q + x * delta
assert t_weighted == q_weighted + x_weighted * delta
print("success")

# Step 4: remove unnecessary rows that were introduced for blinding the choice vector
# Sender outputs qj with j in [0, l]
# Receiver outputs (xj, tj) with j in [0, l]
Q_filtered = Q[0:l, 0:k]
X_filtered = X[0:l, 0:k]
T_filtered = T[0:l, 0:k]

# Step 5: randomize to remove any leaking bits of Delta, not implemented here
# See figure 7 of the paper (for ROT) and https://o1-labs.github.io/proof-systems/fundamentals/zkbook_2pc/ote.html (for COT)
